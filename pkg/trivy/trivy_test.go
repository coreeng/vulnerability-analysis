package trivy

import (
	"context"
	"fmt"
	tapis "github.com/aquasecurity/trivy-operator/pkg/apis/aquasecurity/v1alpha1"
	vaerror "github.com/coreeng/vulnerability-analysis/pkg/error"
	"github.com/coreeng/vulnerability-analysis/pkg/kubernetes"
	"github.com/pkg/errors"
	"sigs.k8s.io/controller-runtime/pkg/client/interceptor"
	"sync/atomic"

	"github.com/stretchr/testify/assert"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	fakecli "sigs.k8s.io/controller-runtime/pkg/client/fake"

	"testing"
	"time"
)

const (
	configPath     = "../../testdata/config/config.yaml"
	defaultTimeout = 100 * time.Millisecond
	testNamespace  = "argocd"
	testImage      = "bitnami/etcd"
	testTag        = "3.5.12-debian-11-r3"
	testRepo       = "index.docker.io"
)

var (
	scheme    = runtime.NewScheme()
	imageName = fmt.Sprintf("%s/%s:%s", testRepo, testImage, testTag)
)

func TestInitClient(t *testing.T) {
	k8sClient, err := kubernetes.GetClient()

	assert.Nil(t, err, "Should not return error")
	assert.NotNil(t, k8sClient, "Failed to create kubernetes client")
}

func TestReportNotFoundForImage(t *testing.T) {
	report, err := loadVulnerabilityReport(testNamespace, "not-exist", defaultTimeout, getK8sCli(t))

	assert.NotNil(t, err, "Should receive error")
	assert.Nil(t, report, "Should not receive report")
	ok := errors.As(err, &vaerror.ValidationFailedError{})
	assert.False(t, ok, "Error should be of type Processing error")
}

func TestNoReportsFoundInNamespace(t *testing.T) {
	report, err := loadVulnerabilityReport("not-exist", imageName, defaultTimeout, getK8sCli(t))

	assert.NotNil(t, err, "Should receive error")
	assert.Nil(t, report, "Should not receive report")
	ok := errors.As(err, &vaerror.ValidationFailedError{})
	assert.False(t, ok, "Error should be of type Processing error")
}

func TestRetryWhenReportNotFound(t *testing.T) {
	var counter count32
	mockClient := newMockClientBuilder(t).
		WithInterceptorFuncs(countingCallsListInterceptor(&counter)).
		Build()

	_, err := loadVulnerabilityReport(testNamespace, "not-exist", 1*time.Second, mockClient)

	assert.NotNil(t, err, "Should receive error")
	assert.Greater(t, counter.get(), int32(1))
}

func TestNotRetriedWhenReportFound(t *testing.T) {
	var counter count32
	mockClient := newMockClientBuilder(t).
		WithLists(mockVulnerabilityReportRsp(testNamespace, testImage, testTag)).
		WithInterceptorFuncs(countingCallsListInterceptor(&counter)).
		Build()

	_, err := loadVulnerabilityReport(testNamespace, imageName, defaultTimeout, mockClient)

	assert.Nil(t, err, "error received")
	assert.Equal(t, int32(1), counter.get())
}

func TestK8ClientReturnsError(t *testing.T) {
	mockClient := newMockClientBuilder(t).
		WithInterceptorFuncs(erroringListInterceptor()).
		Build()

	_, err := loadVulnerabilityReport(testNamespace, "not-exist", 1*time.Second, mockClient)

	assert.NotNil(t, err, "Should receive error")
}

func TestExistingReport(t *testing.T) {
	report, err := loadVulnerabilityReport(testNamespace, imageName, defaultTimeout, getK8sCli(t))

	assert.Nil(t, err, "error received")
	assert.NotNil(t, report, "No report")
	if report != nil {
		assert.EqualValues(t, report.ImageName, imageName, "Image name does not match")
		assert.EqualValues(t, report.CriticalCount, 2, "CriticalCount does not match")
		assert.EqualValues(t, report.HighCount, 28, "HighCount does not match")
		assert.EqualValues(t, report.MediumCount, 48, "MediumCount does not match")
		assert.EqualValues(t, report.LowCount, 80, "LowCount does not match")
		assert.EqualValues(t, report.UnknownCount, 0, "UnknownCount does not match")
	}
}

func TestAnalyseReportSuccess(t *testing.T) {
	err := analyseTrivy(testNamespace, imageName, configPath, defaultTimeout)

	assert.Nil(t, err, "error received")
}

func TestAnalyseReportFailure(t *testing.T) {

	err := analyseTrivy(testNamespace, "index.docker.io/bitnami/etcd:3.5.12-debian-11-r3-error",
		configPath, defaultTimeout)

	assert.NotNil(t, err, "Error not received")
}

func TestAnalyseInvalidConfig(t *testing.T) {

	err := analyseTrivy(testNamespace, "index.docker.io/bitnami/etcd:3.5.12-debian-11-r3",
		"../../testdata/config/config-error.yaml", defaultTimeout)

	assert.NotNil(t, err, "Error not received")
}

func TestAnalyseReportNotFound(t *testing.T) {

	err := analyseTrivy(testNamespace, "not-exist", configPath, defaultTimeout)

	assert.NotNil(t, err, "Error not received")
}

func getK8sCli(t *testing.T) client.Client {
	k8sClient, err := kubernetes.GetClient()
	assert.Nil(t, err, "Should not return error")
	return k8sClient
}

func newMockClientBuilder(t *testing.T) *fakecli.ClientBuilder {
	if err := tapis.AddToScheme(scheme); err != nil {
		assert.NotNil(t, err, "Error received")
	}
	return fakecli.NewClientBuilder().WithScheme(scheme)
}

func countingCallsListInterceptor(counter *count32) interceptor.Funcs {
	return interceptor.Funcs{
		List: func(ctx context.Context, client client.WithWatch, list client.ObjectList, opts ...client.ListOption) error {
			counter.inc()
			return client.List(ctx, list, opts[0])
		},
	}
}

func erroringListInterceptor() interceptor.Funcs {
	return interceptor.Funcs{
		List: func(ctx context.Context, client client.WithWatch, list client.ObjectList, opts ...client.ListOption) error {
			return errors.New("Error when calling List operation")
		},
	}
}

func mockVulnerabilityReportRsp(namespace, image, tag string) *tapis.VulnerabilityReportList {
	return &tapis.VulnerabilityReportList{
		TypeMeta: metav1.TypeMeta{
			Kind:       "VulnerabilityReportList",
			APIVersion: "aquasecurity.github.io/v1alpha1",
		},
		ListMeta: metav1.ListMeta{
			ResourceVersion: "1",
		},
		Items: []tapis.VulnerabilityReport{
			{
				TypeMeta: metav1.TypeMeta{
					Kind:       "VulnerabilityReport",
					APIVersion: "aquasecurity.github.io/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      "example-report-1",
					Namespace: namespace,
				},
				Report: tapis.VulnerabilityReportData{
					Registry: tapis.Registry{Server: testRepo},
					Artifact: tapis.Artifact{Repository: image, Tag: tag},
				},
			},
		},
	}
}

type count32 int32

func (c *count32) inc() int32 {
	return atomic.AddInt32((*int32)(c), 1)
}

func (c *count32) get() int32 {
	return atomic.LoadInt32((*int32)(c))
}
